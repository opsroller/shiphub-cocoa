--- left.m	2016-10-07 14:34:48.000000000 -0700
+++ right.m	2016-10-07 14:34:57.000000000 -0700
@@ -20,6 +20,7 @@
 #import "JSON.h"
 #import "TimeSeries.h"
 #import "GHNotificationManager.h"
+#import "Billing.h"
 
 #import "LocalAccount.h"
 #import "LocalUser.h"
@@ -36,6 +37,8 @@
 #import "LocalNotification.h"
 #import "LocalQuery.h"
 #import "LocalReaction.h"
+#import "LocalHidden.h"
+#import "LocalProject.h"
 
 #import "Issue.h"
 #import "IssueComment.h"
@@ -44,6 +47,7 @@
 #import "CustomQuery.h"
 #import "Reaction.h"
 #import "Milestone.h"
+#import "Project.h"
 
 #import "Error.h"
 
@@ -60,6 +64,10 @@
 NSString *const DataStoreUpdatedProblemsKey = @"DataStoreUpdatedProblemsKey";
 NSString *const DataStoreUpdateProblemSourceKey = @"DataStoreUpdateProblemSourceKey";
 
+NSString *const DataStoreDidChangeReposHidingNotification = @"DataStoreDidChangeReposHidingNotification";
+NSString *const DataStoreHiddenReposKey = @"DataStoreHiddenReposKey";
+NSString *const DataStoreUnhiddenReposKey = @"DataStoreUnhiddenReposKey";
+
 NSString *const DataStoreDidUpdateOutboxNotification = @"DataStoreDidUpdateOutboxNotification";
 NSString *const DataStoreOutboxResolvedProblemIdentifiersKey = @"DataStoreOutboxResolvedProblemIdentifiersKey";
 
@@ -81,21 +89,30 @@
 
 NSString *const DataStoreNeedsMandatorySoftwareUpdateNotification = @"DataStoreNeedsMandatorySoftwareUpdateNotification";
 
+NSString *const DataStoreBillingStateDidChangeNotification = @"DataStoreBillingStateDidChangeNotification";
+
+@interface SyncCacheKey : NSObject <NSCopying>
+
++ (SyncCacheKey *)keyWithEntity:(NSString *)entity identifier:(NSNumber *)identifier;
++ (SyncCacheKey *)keyWithManagedObject:(NSManagedObject *)obj;
+
+@property (nonatomic, readonly) NSString *entity;
+@property (nonatomic, readonly) NSNumber *identifier;
+
+@end
+
 /*
  Change History:
  1: First Version
  2: Server Integration
  3: realartists/shiphub-cocoa#109 Handle PRs in the database
  4: realartists/shiphub-cocoa#76 Support multiple assignees
+ 5: Milestone and repo hiding (realartists/shiphub-cocoa#157 realartists/shiphub-cocoa#145)
+ 6: realartists/shiphub-cocoa#217 User.queries needs to be modeled as to-many relationship
  */
-static const NSInteger CurrentLocalModelVersion = 4;
+static const NSInteger CurrentLocalModelVersion = 6;
 
 @interface DataStore () <SyncConnectionDelegate> {
-    NSManagedObjectModel *_mom;
-    NSPersistentStore *_persistentStore;
-    NSPersistentStoreCoordinator *_persistentCoordinator;
-    NSManagedObjectContext *_moc;
-    
     NSLock *_metadataLock;
     
     dispatch_queue_t _needsMetadataQueue;
@@ -109,7 +126,6 @@
     NSString *_purgeVersion;
     
     NSMutableDictionary *_syncCache; // only manipulated within _moc.
-    NSMutableDictionary *_idCache;   // ""
     
     NSInteger _initialSyncProgress;
     
@@ -118,10 +134,16 @@
 }
 
 @property (strong) Auth *auth;
+@property (strong) Billing *billing;
 @property (strong) ServerConnection *serverConnection;
 @property (strong) SyncConnection *syncConnection;
 @property (strong) GHNotificationManager *ghNotificationManager;
 
+@property (strong) NSManagedObjectModel *mom;
+@property (strong) NSManagedObjectContext *moc;
+@property (strong) NSPersistentStore *persistentStore;
+@property (strong) NSPersistentStoreCoordinator *persistentCoordinator;
+
 @property (readwrite, strong) NSDate *lastUpdated;
 
 @property (readwrite, strong) MetadataStore *metadataStore;
@@ -214,12 +236,13 @@
         _queryUploadProcessing = [NSMutableSet set];
         _needsQuerySyncItems = [NSMutableArray array];
         _needsQuerySyncQueue = dispatch_queue_create("DataStore.ResolveQueries", NULL);
-        _idCache = [NSMutableDictionary new];
         
         if (![self openDB]) {
             return nil;
         }
         
+        self.billing = [[Billing alloc] initWithDataStore:self];
+        
         self.serverConnection = [[[[self class] serverConnectionClass] alloc] initWithAuth:_auth];
         self.syncConnection = [[[[self class] syncConnectionClassWithAuth:_auth] alloc] initWithAuth:_auth];
         self.syncConnection.delegate = self;
@@ -228,7 +251,7 @@
         [self loadQueries];
         [self updateSyncConnectionWithVersions];
         
-        _ghNotificationManager = [[GHNotificationManager alloc] initWithManagedObjectContext:_moc auth:_auth store:self];
+        _ghNotificationManager = [[GHNotificationManager alloc] initWithDataStore:self];
     }
     return self;
 }
@@ -290,7 +313,7 @@
         return NO;
     }
     
-    if (previousStoreVersion < 4) {
+    if (previousStoreVersion < 6) {
         DebugLog(@"Updating to version %td database from %td. Forcing database re-creation.", CurrentLocalModelVersion, previousStoreVersion);
         forceRecreate = YES;
     }
@@ -330,7 +353,6 @@
     _moc.undoManager = nil; // don't care about undo-ing here, and it costs performance to have an undo manager.
     
     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mocDidChange:) name:NSManagedObjectContextObjectsDidChangeNotification object:_moc];
-    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mocDidSave:) name:NSManagedObjectContextDidSaveNotification object:_moc];
     
     BOOL needsSnapshotRebuild = NO;
     BOOL needsKeywordUsageRebuild = NO;
@@ -443,7 +465,9 @@
 }
 
 - (void)loadMetadata {
-    self.metadataStore = [[MetadataStore alloc] initWithMOC:_moc];
+    [_moc performBlockAndWait:^{
+        self.metadataStore = [[MetadataStore alloc] initWithMOC:_moc billingState:_billing.state];
+    }];
 }
 
 - (void)updateSyncConnectionWithVersions {
@@ -501,25 +525,14 @@
             if (obj) break;
         }
     } else {
-        NSString *key = [NSString stringWithFormat:@"%@.%lld", entityName, identifier.longLongValue];
+        id key = [SyncCacheKey keyWithEntity:entityName identifier:identifier];
         obj = _syncCache[key];
-        if (!obj) {
-            NSManagedObjectID *objID = _idCache[key];
-            if (objID) {
-                NSAssert([[[objID entity] name] isEqualToString:entityName], @"cached object has the right entity");
-                obj = [_moc objectWithID:objID];
-                if (obj) {
-                    NSAssert([[(id)obj identifier] isEqual:identifier], @"cached object has the right identifier");
-                    _syncCache[key] = obj;
-                }
-            }
-        }
     }
     return obj;
 }
 
-- (NSString *)cacheKeyWithObject:(NSManagedObject *)obj {
-    return [NSString stringWithFormat:@"%@.%lld", obj.entity.name, [[(id)obj identifier] longLongValue]];
+- (id)cacheKeyWithObject:(NSManagedObject *)obj {
+    return [SyncCacheKey keyWithManagedObject:obj];
 }
 
 // Must be called on _moc
@@ -532,9 +545,8 @@
         fetch.fetchLimit = 1;
         obj = [[_moc executeFetchRequest:fetch error:NULL] firstObject];
         if (obj) {
-            NSString *key = [self cacheKeyWithObject:obj];
+            id key = [self cacheKeyWithObject:obj];
             _syncCache[key] = obj;
-            _idCache[key] = [obj objectID];
         }
     }
     return obj;
@@ -564,9 +576,8 @@
         NSArray *found = [_moc executeFetchRequest:fetch error:NULL];
         for (id obj in found) {
             NSNumber *identifier = [obj identifier];
-            NSString *key = [self cacheKeyWithObject:obj];
+            id key = [self cacheKeyWithObject:obj];
             _syncCache[key] = obj;
-            _idCache[key] = [obj objectID];
             results[identifier] = obj;
         }
         NSDictionary *lookup = [NSDictionary lookupWithObjects:found keyPath:@"identifier"];
@@ -580,7 +591,7 @@
 - (__kindof NSManagedObject *)insertManagedObjectWithIdentifier:(NSNumber *)identifier entityName:(NSString *)entityName {
     NSManagedObject *obj = [NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:_moc];
     [obj setValue:identifier forKey:@"identifier"];
-    NSString *key = [NSString stringWithFormat:@"%@.%lld", entityName, identifier.longLongValue];
+    NSString *key = [self cacheKeyWithObject:obj];
     _syncCache[key] = obj;
     return obj;
 }
@@ -728,7 +739,7 @@
                             if (!_mom.entitiesByName[relName]) {
                                 for (NSEntityDescription *sub in rel.destinationEntity.subentities) {
                                     NSString *jsonType = sub.userInfo[@"jsonType"];
-                                    if ([jsonType isEqualToString:@"type"]) {
+                                    if ([jsonType isEqualToString:type]) {
                                         relName = sub.name;
                                         break;
                                     }
@@ -798,11 +809,136 @@
     }
 }
 
+- (NSDictionary<NSString *, NSSet *> *)identifiersInSyncEntries:(NSArray<SyncEntry *> *)entries {
+    NSArray *entriesByEntity = [entries partitionByKeyPath:@"entityName"];
+    NSMutableDictionary *identifiers = [NSMutableDictionary new];
+    
+    void (^note)(NSString *, NSNumber *) = ^(NSString *entityName, NSNumber *identifier) {
+        NSMutableSet *s = identifiers[entityName];
+        if (!s) {
+            identifiers[entityName] = s = [NSMutableSet new];
+        }
+        [s addObject:identifier];
+    };
+    
+    void (^noteArr)(NSString *, NSArray *) = ^(NSString *entityName, NSArray *arr) {
+        NSMutableSet *s = identifiers[entityName];
+        if (!s) {
+            identifiers[entityName] = s = [NSMutableSet new];
+        }
+        [s addObjectsFromArray:arr];
+    };
+    
+    for (NSArray *part in entriesByEntity) {
+        SyncEntry *r = part[0];
+        NSString *type = r.entityName;
+        NSString *entityName = [NSString stringWithFormat:@"Local%@", [type PascalCase]];
+        NSEntityDescription *entity = _mom.entitiesByName[entityName];
+        if (!entity) continue;
+        
+        for (SyncEntry *e in part) {
+            note(entityName, e.data[@"identifier"]);
+        }
+        
+        NSDictionary *relationships = entity.relationshipsByName;
+        for (NSString *key in [relationships allKeys]) {
+            NSRelationshipDescription *rel = relationships[key];
+            
+            if ([key isEqualToString:@"labels"]) {
+                continue;
+            }
+            
+            NSString *syncDictKey = rel.userInfo[@"jsonKey"];
+            if (!syncDictKey) syncDictKey = key;
+            
+            for (SyncEntry *e in part) {
+                if (e.action != SyncEntryActionSet) continue;
+                
+                if (rel.toMany) {
+                    // to many relationships refer by identifiers or by actual populated objects that have identifiers
+                    NSArray *related = e.data[syncDictKey];
+                    
+                    if (!related) {
+                        continue;
+                    }
+                    
+                    NSArray *relatedIDs = nil;
+                    if ([[related firstObject] isKindOfClass:[NSDictionary class]]) {
+                        relatedIDs = [related arrayByMappingObjects:^id(NSDictionary *x) {
+                            return x[@"identifier"];
+                        }];
+                    } else {
+                        relatedIDs = related;
+                    }
+                    if (!relatedIDs) relatedIDs = @[];
+                    
+                    noteArr(rel.destinationEntity.name, relatedIDs);
+                } else {
+                    id related = e.data[syncDictKey];
+                    
+                    if (!related) continue;
+                    
+                    id relatedID = related;
+                    if ([related isKindOfClass:[NSDictionary class]]) {
+                        relatedID = related[@"identifier"];
+                    } else if (related == [NSNull null]) {
+                        relatedID = nil;
+                    }
+
+                    if (relatedID) {
+                        note(rel.destinationEntity.name, relatedID);
+                    }
+                }
+            }
+        }
+    }
+    
+    return identifiers;
+}
+
+// must be called on _moc. Does not call save:.
+- (void)ensureEntitiesForIdentifiers:(NSDictionary<NSString *, NSSet *> *)identifiers {
+    for (NSString *entityName in identifiers) {
+        NSSet *idNums = identifiers[entityName];
+        
+        NSFetchRequest *fetch = [NSFetchRequest fetchRequestWithEntityName:entityName];
+        fetch.predicate = [NSPredicate predicateWithFormat:@"identifier IN %@", idNums];
+        
+        NSError *err = nil;
+        NSArray *existing = [_moc executeFetchRequest:fetch error:&err];
+        if (err) {
+            ErrLog(@"%@", err);
+            err = nil;
+        }
+        
+        NSDictionary *lookup = [NSDictionary lookupWithObjects:existing keyPath:@"identifier"];
+        
+        for (NSNumber *identifier in idNums) {
+            NSManagedObject *obj = lookup[identifier];
+            if (!obj) {
+                NSEntityDescription *entity = _mom.entitiesByName[entityName];
+                if (!entity.abstract) {
+                    obj = [NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:_moc];
+                    [obj setValue:identifier forKey:@"identifier"];
+                } else {
+                    continue;
+                }
+            }
+            id key = [self cacheKeyWithObject:obj];
+            _syncCache[key] = obj;
+        }
+    }
+}
+
 - (void)syncConnection:(SyncConnection *)sync receivedEntries:(NSArray<SyncEntry *> *)entries versions:(NSDictionary *)versions progress:(double)progress
 {
+    NSDictionary *identifiers = [self identifiersInSyncEntries:entries];
+    
     [_moc performBlock:^{
         _syncCache = [NSMutableDictionary new];
         
+        [self ensureEntitiesForIdentifiers:identifiers];
+        
         [self writeSyncObjects:entries];
         [self updateSyncVersions:versions];
         
@@ -903,23 +1039,40 @@
     }
 }
 
+- (void)checkForHiddenRepoChanges:(NSNotification *)note {
+    NSMutableArray *nowHidden = [NSMutableArray new];
+    NSMutableArray *nowUnhidden = [NSMutableArray new];
+    
+    [note enumerateModifiedObjects:^(id obj, CoreDataModificationType modType, BOOL *stop) {
+        if ([obj isKindOfClass:[LocalHidden class]]) {
+            LocalHidden *hidden = obj;
+            LocalRepo *repo = hidden.repository;
+            if (repo && repo.fullName) {
+                [modType == CoreDataModificationTypeDeleted ? nowUnhidden : nowHidden addObject:repo.fullName];
+            }
+        }
+    }];
+    
+    if (nowHidden.count > 0 || nowUnhidden.count > 0) {
+        [self postNotification:DataStoreDidChangeReposHidingNotification userInfo:@{ DataStoreHiddenReposKey : nowHidden, DataStoreUnhiddenReposKey : nowUnhidden }];
+    }
+}
+
 - (void)mocDidChange:(NSNotification *)note {
     //DebugLog(@"%@", note);
     
     if ([MetadataStore changeNotificationContainsMetadata:note]) {
         DebugLog(@"Updating metadata store");
-        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-            MetadataStore *store = [[MetadataStore alloc] initWithMOC:_moc];
-            self.metadataStore = store;
-            
-            dispatch_async(dispatch_get_main_queue(), ^{
-                NSDictionary *userInfo = @{ DataStoreMetadataKey : store };
-                [[NSNotificationCenter defaultCenter] postNotificationName:DataStoreDidUpdateMetadataNotification object:self userInfo:userInfo];
-            });
+        MetadataStore *store = [[MetadataStore alloc] initWithMOC:_moc billingState:_billing.state];
+        self.metadataStore = store;
+        dispatch_async(dispatch_get_main_queue(), ^{
+            NSDictionary *userInfo = @{ DataStoreMetadataKey : store };
+            [[NSNotificationCenter defaultCenter] postNotificationName:DataStoreDidUpdateMetadataNotification object:self userInfo:userInfo];
         });
     }
     
     [self checkForCustomQueryChanges:note];
+    [self checkForHiddenRepoChanges:note];
     
     // calculate which issues are affected by this change
     NSArray *changedIssueIdentifiers = [self changedIssueIdentifiers:note];
@@ -932,26 +1085,21 @@
     }
 }
 
-- (void)mocDidSave:(NSNotification *)note {
-    for (id obj in note.userInfo[NSInsertedObjectsKey]) {
-        if ([obj respondsToSelector:@selector(identifier)]) {
-            NSManagedObjectID *objectID = [obj objectID];
-            if (![objectID isTemporaryID]) {
-                NSString *key = [self cacheKeyWithObject:obj];
-                _idCache[key] = objectID;
-            }
-        }
+- (NSPredicate *)issuesPredicate:(NSPredicate *)basePredicate {
+    NSPredicate *extra = nil;
+    if (_billing.limited) {
+        extra = [NSPredicate predicateWithFormat:@"repository.private = NO AND repository.hidden = nil AND repository.fullName != nil"];
+    } else {
+        extra = [NSPredicate predicateWithFormat:@"repository.hidden = nil AND repository.fullName != nil"];
     }
+    
+    return [[basePredicate coreDataPredicate] and:extra];
 }
 
 - (void)issuesMatchingPredicate:(NSPredicate *)predicate completion:(void (^)(NSArray<Issue*> *issues, NSError *error))completion {
     return [self issuesMatchingPredicate:predicate sortDescriptors:@[[NSSortDescriptor sortDescriptorWithKey:@"number" ascending:YES]] options:nil completion:completion];
 }
 
-- (NSPredicate *)issuesPredicate:(NSPredicate *)basePredicate {
-    return [[basePredicate predicateByFoldingExpressions] and:[NSPredicate predicateWithFormat:@"repository.fullName != nil AND pullRequest = NO"]];
-}
-
 - (void)issuesMatchingPredicate:(NSPredicate *)predicate sortDescriptors:(NSArray<NSSortDescriptor*> *)sortDescriptors completion:(void (^)(NSArray<Issue*> *issues, NSError *error))completion {
     return [self issuesMatchingPredicate:predicate sortDescriptors:sortDescriptors options:nil completion:completion];
 }
@@ -1726,6 +1874,160 @@
     });
 }
 
+- (void)addProjectNamed:(NSString *)projName body:(NSString *)projBody inRepo:(Repo *)repo completion:(void (^)(Project *proj, NSError *error))completion
+{
+    NSParameterAssert(projName);
+    NSParameterAssert(repo);
+    NSParameterAssert(completion);
+    
+    NSMutableDictionary *contents = [NSMutableDictionary new];
+    contents[@"name"] = projName;
+    if ([projBody length]) {
+        contents[@"body"] = projBody;
+    }
+    
+    NSString *endpoint = [NSString stringWithFormat:@"/repos/%@/projects", repo.fullName];
+    [self.serverConnection perform:@"POST" on:endpoint headers:@{@"Accept":@"application/vnd.github.inertia-preview+json"} body:contents completion:^(id jsonResponse, NSError *error) {
+        if (error) {
+            RunOnMain(^{
+                completion(nil, error);
+            });
+        } else {
+            [_moc performBlock:^{
+                LocalProject *proj = [NSEntityDescription insertNewObjectForEntityForName:@"LocalProject" inManagedObjectContext:_moc];
+                NSMutableDictionary *projDict = [[JSON parseObject:jsonResponse withNameTransformer:[JSON githubToCocoaNameTransformer]] mutableCopy];
+                projDict[@"repository"] = repo.identifier;
+                [proj mergeAttributesFromDictionary:projDict];
+                [self updateRelationshipsOn:proj fromSyncDict:projDict];
+                
+                Project *result = [[Project alloc] initWithLocalItem:proj];
+                NSError *cdErr = nil;
+                [_moc save:&cdErr];
+                if (cdErr) {
+                    RunOnMain(^{
+                        completion(nil, cdErr);
+                    });
+                } else {
+                    RunOnMain(^{
+                        completion(result, nil);
+                    });
+                }
+            }];
+        }
+    }];
+}
+
+- (void)deleteProject:(Project *)proj completion:(void (^)(NSError *error))completion {
+    NSParameterAssert(proj);
+    NSParameterAssert(completion);
+    
+    [_moc performBlock:^{
+        NSFetchRequest *fetch = [NSFetchRequest fetchRequestWithEntityName:@"LocalProject"];
+        fetch.predicate = [NSPredicate predicateWithFormat:@"identifier = %@", proj.identifier];
+        fetch.fetchLimit = 1;
+        
+        LocalProject *lp = [[_moc executeFetchRequest:fetch error:NULL] firstObject];
+        
+        if (lp.number && lp.repository.fullName) {
+            NSString *endpoint = [NSString stringWithFormat:@"/repos/%@/projects/%@", lp.repository.fullName, lp.number];
+            [self.serverConnection perform:@"DELETE" on:endpoint headers:@{@"Accept":@"application/vnd.github.inertia-preview+json"} body:nil completion:^(id jsonResponse, NSError *error) {
+                
+                if (!error) {
+                    [_moc performBlock:^{
+                        [_moc deleteObject:lp];
+                        [_moc save:NULL];
+                        
+                        RunOnMain(^{
+                            completion(nil);
+                        });
+                    }];
+                } else {
+                    RunOnMain(^{
+                        completion(error);
+                    });
+                }
+                
+            }];
+        } else {
+            RunOnMain(^{
+                completion([NSError shipErrorWithCode:ShipErrorCodeInternalInconsistencyError]);
+            });
+        }
+    }];
+}
+
+#pragma mark - Milestone and Repo Hiding
+
+- (void)setHidden:(BOOL)hidden forMilestones:(NSArray<Milestone *> *)milestones completion:(void (^)(NSError *error))completion {
+    NSParameterAssert(milestones);
+    
+    [_moc performBlock:^{
+        NSFetchRequest *fetchMilestones = [NSFetchRequest fetchRequestWithEntityName:@"LocalMilestone"];
+        fetchMilestones.predicate = [NSPredicate predicateWithFormat:@"identifier IN %@", [milestones arrayByMappingObjects:^id(id obj) {
+            return [obj identifier];
+        }]];
+        
+        NSArray *localMilestones = [_moc executeFetchRequest:fetchMilestones error:NULL];
+        
+        if (!hidden) {
+            NSFetchRequest *fetchHiddens = [NSFetchRequest fetchRequestWithEntityName:@"LocalHidden"];
+            fetchHiddens.predicate = [NSPredicate predicateWithFormat:@"milestone IN %@", localMilestones];
+            
+            NSArray *localHiddens = [_moc executeFetchRequest:fetchHiddens error:NULL];
+            
+            for (LocalHidden *h in localHiddens) {
+                [_moc deleteObject:h];
+            }
+        } else {
+            for (LocalMilestone *lm in localMilestones) {
+                if (lm.hidden == nil) {
+                    LocalHidden *h = [NSEntityDescription insertNewObjectForEntityForName:@"LocalHidden" inManagedObjectContext:_moc];
+                    lm.hidden = h;
+                }
+            }
+        }
+        
+        [_moc save:NULL];
+        
+        RunOnMain(^{
+            if (completion) completion(nil);
+        });
+    }];
+}
+
+- (void)setHidden:(BOOL)hidden forRepos:(NSArray<Repo *> *)repos completion:(void (^)(NSError *error))completion {
+    NSParameterAssert(repos);
+    
+    [_moc performBlock:^{
+        NSFetchRequest *fetchRepos = [NSFetchRequest fetchRequestWithEntityName:@"LocalRepo"];
+        fetchRepos.predicate = [NSPredicate predicateWithFormat:@"identifier IN %@", [repos arrayByMappingObjects:^id(id obj) {
+            return [obj identifier];
+        }]];
+        
+        NSArray *localRepos = [_moc executeFetchRequest:fetchRepos error:NULL];
+        
+        for (LocalRepo *lr in localRepos) {
+            if (hidden) {
+                if (!lr.hidden) {
+                    LocalHidden *h = [NSEntityDescription insertNewObjectForEntityForName:@"LocalHidden" inManagedObjectContext:_moc];
+                    lr.hidden = h;
+                }
+            } else {
+                if (lr.hidden) {
+                    [_moc deleteObject:lr.hidden];
+                }
+            }
+        }
+        
+        [_moc save:NULL];
+        
+        RunOnMain(^{
+            if (completion) completion(nil);
+        });
+    }];
+}
+
+
 #pragma mark - Time Series
 
 - (void)timeSeriesMatchingPredicate:(NSPredicate *)predicate startDate:(NSDate *)startDate endDate:(NSDate *)endDate completion:(void (^)(TimeSeries *series, NSError *error))completion {
@@ -2087,7 +2389,7 @@
         NSArray *notes = [_moc executeFetchRequest:fetch error:NULL];
         
         if ([notes count]) {
-            [_serverConnection perform:@"PUT" on:@"/notifications" body:nil completion:^(id jsonResponse, NSError *error) {
+            [_serverConnection perform:@"PUT" on:@"/notifications" body:@{} completion:^(id jsonResponse, NSError *error) {
                 if (!error) {
                     [_moc performBlock:^{
                         for (LocalNotification *note in notes) {
@@ -2267,4 +2569,43 @@
     });
 }
 
+#pragma mark - SyncConnection billing update
+
+- (void)syncConnection:(SyncConnection *)sync didReceiveBillingUpdate:(NSDictionary *)update {
+    [_billing updateWithRecord:update];
+}
+
+@end
+
+@implementation SyncCacheKey {
+    NSUInteger _hash;
+}
+
++ (SyncCacheKey *)keyWithEntity:(NSString *)entity identifier:(NSNumber *)identifier {
+    SyncCacheKey *key = [SyncCacheKey new];
+    key->_entity = entity;
+    key->_identifier = identifier;
+    key->_hash = [identifier hash] + [entity hash];
+    return key;
+}
+
++ (SyncCacheKey *)keyWithManagedObject:(NSManagedObject *)obj {
+    return [SyncCacheKey keyWithEntity:obj.entity.name identifier:[(id)obj identifier]];
+}
+
+- (id)copyWithZone:(nullable NSZone *)zone {
+    return self;
+}
+
+- (NSUInteger)hash {
+    return _hash;
+}
+
+- (BOOL)isEqual:(id)object {
+    SyncCacheKey *other = object;
+    if (_hash != other->_hash) return NO;
+    return _identifier.longLongValue == other->_identifier.longLongValue
+        && [_entity isEqualToString:other->_entity];
+}
+
 @end
